#!/usr/bin/python
__doc__ = 'COLLECTBINARIES -- collect binary neutron star data that satisfies specified constraints'
__usage__ = 'collectbinaries [-v] [-M 1.93] [-d ./dat/] [-o ./dat/]'
__author__ = 'philippe.landry@ligo.org'
__date__ = '04-2019'

import numpy as np
from optparse import OptionParser
import os
import glob

parser = OptionParser(usage=__usage__, description=__doc__)
parser.add_option('-M', '--mmaxobs', default='1.93', help='observational lower bound on the NS maximum mass to use, DEFAULT=1.93', metavar='1.93')
parser.add_option('-d', '--dir', default='./dat/', help='path to directory housing NS properties data, DEFAULT=./dat/', metavar='./dat/')
parser.add_option('-o', '--outdir', default='./dat/', help='path to output directory, DEFAULT=./dat/', metavar='./dat/')
parser.add_option('-t', '--tag', default='SAMP', help='tag for output data file, DEFAULT=SAMP', metavar='SAMP')
parser.add_option('-v', '--verbose', action='store_true', default=False, help='toggle verbose output, DEFAULT=False', metavar='False')

opts, args = parser.parse_args()
mobs = float(opts.mmaxobs)
indir = str(opts.dir)
outdir = str(opts.outdir)
tag = str(opts.tag)
verb = opts.verbose

outfile = open(outdir+"SAMP.csv","w")
dropfile = open(outdir+"DROP.csv","w")
failfile = open(outdir+"FAIL.csv","w")

failfile.write('EoS \n')

# CHECK BINARY PROPERTIES AND CONCATENATE DATA, DISCARDING EOSS WITH INSUFFICIENTLY LARGE MMAX

j=0
dirslist = glob.glob(outdir+"DRAW*")
for dirs in dirslist:

	eoslist = glob.glob(dirs+"/MACRO*")
	for eos in eoslist:
	
		if verb == True: print 'Read properties of binaries with '+str(eos)+' stars'
	
		shortname = eos.split('MACRO')[-1]
		sampfile = eos+'/SAMP'+shortname+'.csv'
	
		lines = 0
		if os.path.isfile(sampfile):
		
			sampcheck = open(sampfile)
			for line in sampcheck: lines = lines+1
			
		else:
		
			if verb == True: print 'No binaries found'
			failfile.write('{0} \n'.format(eos))
			
		if lines > 1:
		
			sampdat = np.genfromtxt(sampfile,delimiter=',',names=True,dtype=None)
			if sampdat.size==1:
				sampdat = np.array([sampdat], dtype=sampdat.dtype)
			props = list(sampdat.dtype.names)
			props = [item for item in props if item not in['EoS','branch1','branch2','M1','M2','Mmax']]
			
			if j==0:
			
				outfile.write(('EoS,branch2,branch1,Mmax,mc_source,q,mtotal_source,m1_source,m2_source,lambda_tilde,' +','.join(props)+'\n').replace('Lambda','lambda'))
				dropfile.write(('EoS,branch2,branch1,Mmax,mc_source,q,mtotal_source,m1_source,m2_source,lambda_tilde,' +','.join(props)+'\n').replace('Lambda','lambda'))
				
				j = j+1
			
			for i in range(len(sampdat['EoS'])):
			
				if verb == True: print 'Checking properties for binary '+str(i)
			
				eosnum = (str(np.asarray(sampdat['EoS'])[i]).split('draw-')[-1]).split('.csv')[0]
				branchnums = [str(np.asarray(sampdat['branch2'])[i]),str(np.asarray(sampdat['branch1'])[i])]
				m1 = np.asarray(sampdat['M1'])[i]
				m2 = np.asarray(sampdat['M2'])[i]
				Mmax = np.asarray(sampdat['Mmax'])[i]
	
				q = m2/m1
				Mc = (m1*m2)**0.6/(m1+m2)**0.2
				M = m1+m2
				
				L1 = np.asarray(sampdat['Lambda1'])[i]
				L2 = np.asarray(sampdat['Lambda2'])[i]
				Ltilde = (16./13.)*((m1+12.*m2)*m1**4*L1+(m2+12.*m1)*m2**4*L2)/M**5
				
				proplist = []
				for prop in props:
				
					proplist.append(str(np.asarray(sampdat[prop])[i]))
					
				if Mmax >= mobs:
				
					if verb == True: print 'Maximum mass ok'
			
					if branchnums[0] != 'BH' and branchnums[1] != 'BH':
						
						if verb == True: print 'Stability ok'
						outfile.write('{0},{1},{2},{3},{4},{5},{6},{7},{8},{9} \n'.format(eosnum,','.join(branchnums),Mmax,Mc,q,M,m1,m2,Ltilde,','.join(proplist)))
						
					else:
						if verb == True: print 'Unstable'
					
				else:
				
					if verb == True: print 'Maximum mass less than '+str(mobs)
				
					dropfile.write('{0},{1},{2},{3},{4},{5},{6},{7},{8},{9} \n'.format(eosnum,','.join(branchnums),Mmax,Mc,q,M,m1,m2,Ltilde,','.join(proplist)))

