#!/usr/bin/python
__doc__ = 'SAMPLE-PRIORS -- sample from mass and EOS priors'
__usage__ = 'sample-priors path/to/eosmetadata.in path/to/output.json [...]'
__author__ = 'pgjlandry@gmail.com'
__date__ = '04-2020'

from optparse import OptionParser
import numpy as np
import numpy.random
import json
import eosinf.tools as tools
import eosinf.priors as priors

parser = OptionParser(usage=__usage__, description=__doc__)
parser.add_option('-n', '--numeos', default=1e3, help='number of EOS samples, DEFAULT=1e3', metavar='NUM_EOS_SAMPLES')
parser.add_option('-N', '--nummass', default=1e2, help='number of mass samples per EOS, DEFAULT=1e2', metavar='NUM_MASS_SAMPLES')
parser.add_option('-m', '--mrange', default='0.,4.', help='bounds on mass prior, DEFAULT="0.,4."', metavar='LB,UB')
parser.add_option('-p', '--mprior', default='flat', help='mass prior distribution, DEFAULT="flat"', metavar='PRIOR_KEY')
parser.add_option('-M', '--mseq', default='0.8,0.8', help='require EOS to support stable NSs over this mass range, DEFAULT="0.8,0.8"', metavar='MINM,MAXM')
parser.add_option('-r', '--randseed', default=2020, help='random seed to use, DEFAULT=2020', metavar='RAND_SEED')
parser.add_option('-o', '--outprec', default=8, help='how many digits of precision to output, DEFAULT=8', metavar='PREC')
parser.add_option('--canon', action='store_false', default=True, help='toggle output of canonical NS properties, DEFAULT=True', metavar='BOOL')
parser.add_option('--maxm', action='store_true', default=False, help='toggle output of max-mass NS properties, DEFAULT=False', metavar='BOOL')
parser.add_option('--minm', action='store_true', default=False, help='toggle output of min-mass NS properties, DEFAULT=False', metavar='BOOL')
parser.add_option('--choosem', default=False, help='toggle output of NS properties at chosen mass, DEFAULT=False', metavar='MASS')
parser.add_option('-v', '--verbose', action='store_true', default=False, help='toggle verbose output, DEFAULT=False', metavar='BOOL')
# add chirp mass/q cut?

opts, args = parser.parse_args()
eosdatfile = str(args[0])
outfile = str(args[1])
numeos = int(opts.numeos)
nummass = int(opts.nummass)
mprior = str(opts.mprior)
mrange = [float(m) for m in str(opts.mrange).split(',')]
mseqrng = [float(m) for m in str(opts.mseq).split(',')]
outprec = "{"+":.{0}E".format(int(opts.outprec)-1)+"}"
canon_true = opts.canon
maxm_true = opts.maxm
minm_true = opts.minm
choosem_true = opts.choosem
if choosem_true: choosem = float(choosem_true)
verb = opts.verbose
np.random.seed(int(opts.randseed))

# PARSE EOS BANK METADATA

if verb: print "parsing eos bank metadata..."

eosdir,mod,subdirname,tablename,macrodirname,delim,ext,eosbanksize,comps,failr = np.genfromtxt(eosdatfile,dtype=None) # read eos bank metadata
eosbanksize = int(eosbanksize)

if verb: print "classifying eos bank by composition..."

if comps == 'None': compidns = []
else: compidns = [int(idn) for idn in str(comps).split(',')] 
compidns.append(eosbanksize) # separate eos by composition
numcomps = len(compidns)
compsize = numeos/numcomps

failr = float(failr) # record fail code for radius integrations

# SAMPLE FROM EOS AND MASS PRIORS
# parallelize?

if verb: print "mapping paths to eos and ns tables..."

idns_list, numeos_list, eosfails_list, macros_list, mbranches_list = [], [], [], [], []
prevcomp = 0
for comp in compidns:
	idrange = np.arange(prevcomp,comp)
	idns = np.random.choice(idrange,size=compsize,replace=False)

	eospaths = [tools.geteospath(idn,eosdir,eosbanksize,mod,subdirname,tablename,delim,ext) for idn in idns]
	macropaths = [tools.getmacropath(idn,eosdir,eosbanksize,mod,subdirname,macrodirname,delim,ext) for idn in idns] # retrieve eos tables and NS properties

	macros = [macropath for macropath in macropaths]
	mseqs = [tools.getmassseq(macro) for macro in macros]
	mbranches = [tools.getmassbranch(macro) for macro in macros]
	mtests = [tools.testmassseq(mseq,mseqrng) for mseq in mseqs]
	rtests = [tools.testr(mbranches[i],macros[i]) for i in range(compsize)]
	tests = [0 if mtests[i] == 0 or rtests[i] == 0 else 1 for i in range(compsize)]
	idns, macros, mseqs, eosfails = tools.removeosfails(idns,macros,mseqs,tests)
	numeostmp = len(idns)

	idns_list.append(idns)
	numeos_list.append(numeostmp)
	eosfails_list.append(eosfails)
	macros_list.append(macros)
	mbranches_list.append(mbranches)
	prevcomp = comp

idns, macros, mbranches, eosfails, eosspares = tools.mergecomps(numcomps,numeos_list,idns_list,macros_list,mbranches_list,eosfails_list)
numeos = len(idns)
macrorels = [tools.getrels(macro) for macro in macros]
bhrels = tools.getbhrels(macros[0][0])
propnames = tools.getpropnames(macros[0][0])

if verb: print "drawing eos and mass samples from priors..."

msamps = []
macroprops = [] # add derived props?
globalprops = []
if canon_true: canonprops = []
if maxm_true: maxmprops = []
if minm_true: minmprops = []
if choosem_true: choosemprops = []
for i in range(numeos):
	msamps_tmp = priors.samplemassprior(nummass,mprior,mrange)
	msamps.append(msamps_tmp)
	macroprops.append([tools.getmacroprops(macrorels[i],mbranches[i],bhrels,M) for M in msamps_tmp])
	globalprops.append([len(mbranches[i][0]),mbranches[i][0][0],mbranches[i][1][-1]])
	if canon_true:
		canonprops.append(tools.getmacroprops(macrorels[i],mbranches[i],bhrels,1.4))
	if maxm_true:
		maxmprops.append(tools.getmacroprops(macrorels[i],mbranches[i],bhrels,mbranches[i][1][-1]))
	if minm_true:
		minmprops.append(tools.getmacroprops(macrorels[i],mbranches[i],bhrels,mbranches[i][0][0]))
	if choosem_true:
		choosemprops.append(tools.getmacroprops(macrorels[i],mbranches[i],bhrels,choosem))

# FORMAT AS JSON FILE

jdata, jdata["mass"], jdata["eos"], jdata["global"] = {}, {}, {}, {}
jdata["eos"]["properties"], jdata["eos"]["unstable"], jdata["eos"]["unused"] = propnames, eosfails, eosspares
jdata["eos"]["live"] = {}
jdata["global"]["properties"] = ["numbranches","Mmin","Mmax"]

if canon_true:
	jdata["canonical"] = {}
	jdata["canonical"]["properties"] = [str(prop)+"_1.4" for prop in propnames]
if maxm_true:
	jdata["maxmass"] = {}
	jdata["maxmass"]["properties"] = [str(prop)+"_Mmax" for prop in propnames]
if minm_true:
	jdata["minmass"] = {}
	jdata["minmass"]["properties"] = [str(prop)+"_Mmin" for prop in propnames]
if choosem_true:
	jdata["mass_"+str(choosem)] = {}
	jdata["mass_"+str(choosem)]["properties"] = [str(prop)+"_"+str(choosem) for prop in propnames]

for i in range(numeos):
	props_str = [[outprec.format(float(prop)) for prop in samp] for samp in macroprops[i]]
	jdata["eos"]["live"][idns[i]] = []
	jdata["eos"]["live"][idns[i]].extend(props_str)
	jdata["mass"][idns[i]] = [outprec.format(float(samp)) for samp in msamps[i]]
	jdata["global"][idns[i]] = [outprec.format(float(prop)) for prop in globalprops[i]]
	if canon_true: jdata["canonical"][idns[i]] = [outprec.format(float(prop)) for prop in canonprops[i]]
	if maxm_true: jdata["maxmass"][idns[i]] = [outprec.format(float(prop)) for prop in maxmprops[i]]
	if minm_true: jdata["minmass"][idns[i]] = [outprec.format(float(prop)) for prop in minmprops[i]]
	if choosem_true: jdata["mass_"+str(choosem)][idns[i]] = [outprec.format(float(prop)) for prop in choosemprops[i]]

with open(outfile, 'w') as outpath:
    json.dump(jdata, outpath)

