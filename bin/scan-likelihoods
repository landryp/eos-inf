#!/bin/bash

obslist=$1

while IFS=, read -r likepath obstype
do

	likemetapath="${likepath%.*}.in"
	bwpath="${likepath%.*}.bw"
	tmppath1="${likepath%.*}.bw.tmp1"
	tmppath2="${likepath%.*}.bw.tmp2"

	parse-likelihood-samples $obstype $likepath $likemetapath

	sumbw=0
	vars=0
	while IFS=, read -r prop lb ub bw
	do		
		if [ "$obstype" == "cbc" ]; then
			if [ "$prop" == "m1" ]; then
				gub=$ub
			elif [ "$prop" == "m2" ]; then
				llb=$lb
			fi
			if [ "$prop" == "m1" ] || [ "$prop" == "m2" ] || [ "$prop" == "Lambda1" ] || [ "$prop" == "Lambda2" ]; then
				sumbw=$(bc <<<"scale=4;$sumbw+$bw")
				vars=$(($vars+1))
			fi
		else
			if [ "$prop" == "m" ]; then
				gub=$ub
				llb=$lb
				sumbw=$(bc <<<"scale=4;$sumbw+$bw")
				vars=$(($vars+1))
			fi
			if [ "$obstype" == "xmr" ] && [ "$prop" == "R" ]; then
				sumbw=$(bc <<<"scale=4;$sumbw+$bw")
				vars=$(($vars+1))
			fi
		fi
	done < $likemetapath

	mbounds="$llb,$gub"
	avgbw=$(bc <<<"scale=4;$sumbw/$vars")

	if [ "$obstype" == "cbc" ]; then
		props="m1 m2 Lambda1 Lambda2"
		avgbw=$(bc <<<"scale=4;$avgbw/1000")

	elif [ "$obstype" == "xmr" ]; then
		props="m R"

	elif [ "$obstype" == "m" ]; then
		props="m"

	else
		props="m"
	fi

	bws=(0 1 2 3 4 5)
	for i in 0 1 2 3 4 5
	do
		j=$((2*$i+1))
		bws[$i]=$(bc <<<"scale=4;$avgbw*$j")
	done
	
	investigate-bandwidth $likepath $props -v --num-proc 50 -b ${bws[0]} -b ${bws[1]} -b ${bws[2]} -b ${bws[3]} -b ${bws[4]} -b ${bws[5]} --weight-column Prior --weight-column-is-log Prior --invert-weight-column Prior > $bwpath

	grep 'mean_logL' $bwpath | tr -d 'mean_logL =' > $tmppath1
	grep 'b=' $bwpath | tr -d 'b =' > $tmppath2

	optbw=1
	maxlogL=-1000
	while IFS=, read -r logL && IFS=, read -r b <&3
	do
		logL=$(echo print $logL | python)
		b=$(echo print $b | python)
		if (( $(echo "$logL > $maxlogL" |bc -l) )); then
			maxlogL=$logL
			optbw=$b
		fi
	done < $tmppath1 3< $tmppath2

	rm $tmppath1 $tmppath2

	bws=(0 1 2 3 4 5 6)
	for i in 0 1 2 3 4 5 6
	do
		j=$(($i-3))
		j=$(bc <<<"scale=4;$j/10")
		j=$(bc <<<"scale=4;$j+1")
		bws[${i}]=$(bc <<<"scale=4;$optbw*$j")
	done

	investigate-bandwidth $likepath $props -v --num-proc 50 -b ${bws[0]} -b ${bws[1]} -b ${bws[2]} -b ${bws[3]} -b ${bws[4]} -b ${bws[5]} -b ${bws[6]} --weight-column Prior --weight-column-is-log Prior --invert-weight-column Prior > $bwpath

	grep 'mean_logL' $bwpath | tr -d 'mean_logL =' > $tmppath1
	grep 'b=' $bwpath | tr -d 'b =' > $tmppath2

	optbw=1
	maxlogL=-1000
	while IFS=, read -r logL && IFS=, read -r b <&3
	do
		logL=$(echo print $logL | python)
		b=$(echo print $b | python)
		if (( $(echo "$logL > $maxlogL" |bc -l) )); then
			maxlogL=$logL
			optbw=$b
		fi
	done < $tmppath1 3< $tmppath2

	rm $tmppath1 $tmppath2

	bws=(0 1 2 3 4 5 6 7 8 9 10)
	for i in 0 1 2 3 4 5 6 7 8 9 10
	do
		j=$(($i-5))
		j=$(bc <<<"scale=4;$j/10")
		j=$(bc <<<"scale=4;$j+1")
		bws[${i}]=$(bc <<<"scale=4;$optbw*$j")
	done

	investigate-bandwidth $likepath $props -v --num-proc 50 -b ${bws[0]} -b ${bws[1]} -b ${bws[2]} -b ${bws[3]} -b ${bws[4]} -b ${bws[5]} -b ${bws[6]} -b ${bws[7]} -b ${bws[8]} -b ${bws[9]} -b ${bws[10]} --weight-column Prior --weight-column-is-log Prior --invert-weight-column Prior > $bwpath

	grep 'mean_logL' $bwpath | tr -d 'mean_logL =' > $tmppath1
	grep 'b=' $bwpath | tr -d 'b =' > $tmppath2

	optbw=1
	maxlogL=-1000
	while IFS=, read -r logL && IFS=, read -r b <&3
	do
		logL=$(echo print $logL | python)
		b=$(echo print $b | python)
		if (( $(echo "$logL > $maxlogL" |bc -l) )); then
			maxlogL=$logL
			optbw=$b
		fi
	done < $tmppath1 3< $tmppath2

	rm $tmppath1 $tmppath2

	echo "$optbw" > $tmppath1
	cat $tmppath1 >  $tmppath2
	cat $bwpath >> $tmppath2
	rm $tmppath1
	mv $tmppath2 $bwpath

done < $obslist
